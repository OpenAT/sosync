<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="GetAllOpenSyncJobs_SELECT" xml:space="preserve">
    <value>with recursive children as (
	-- roots
	select *
	from sync_table
	where parent_job_id is null and job_state in ('new', 'inprogress')

	union all
	
	-- children
	select child.*
	from sync_table as child
	inner join sync_table parent on child.parent_job_id = parent.job_id
)
select * from children;</value>
  </data>
  <data name="GetFirstOpenSynJobAndChildren_SELECT" xml:space="preserve">
    <value>with recursive children as (
	-- roots
	select * from (
		select *
		from sync_table
		where parent_job_id is null and job_state in ('new', 'inprogress')
		limit 1
	) as first_parent

	union all
	
	-- children
	select child.*
	from sync_table as child
	inner join sync_table parent on child.parent_job_id = parent.job_id
)
select * from children;</value>
  </data>
  <data name="SetupAddColumn_SCRIPT" xml:space="preserve">
    <value>DO $$ 
    BEGIN
        BEGIN
            ALTER TABLE {0} ADD COLUMN {1} {2};
        EXCEPTION
            WHEN duplicate_column THEN RAISE NOTICE 'column {1} already exists in {0}.';
        END;
    END;
$$</value>
  </data>
  <data name="SetupDatabase_SCRIPT" xml:space="preserve">
    <value>CREATE TABLE IF NOT EXISTS sync_table
(
 -- SyncJob
  job_id serial,
  job_date timestamp without time zone not null,
  
  -- Sosync only
  job_fs_id integer,
  job_fso_id integer,
  job_last_change timestamp without time zone,
  
  -- SyncJob source
  job_source_system text,
  job_source_model text,
  job_source_record_id integer not null,
  
  -- SyncJob info
  job_fetched timestamp without time zone,
  job_start timestamp without time zone,
  job_end timestamp without time zone,
  job_run_count integer not null default 0,
  job_state text not null,
  job_error_code text,
  job_error_text text,
  job_log text,
  
  -- Parent job_child_end
  parent_job_id integer,

  -- Child jobs processing time
  child_job_start timestamp without time zone,
  child_job_end timestamp without time zone,
  
  -- Synchronization source
  sync_source_system text,
  sync_source_model text,
  sync_source_record_id integer,

  -- Synchronization target
  sync_target_system text,
  sync_target_model text,
  sync_target_record_id integer,
  
  -- Synchronization info
  sync_source_data text,
  sync_target_data_before_update text,
  sync_target_request text,
  sync_target_answer text,

  -- Synchronization processing time
  sync_start timestamp without time zone,
  sync_end timestamp without time zone,

  constraint synctable_primary_key primary key(job_id)
)
with (
  OIDS=false
);</value>
  </data>
  <data name="SetupDropColumn_SCRIPT" xml:space="preserve">
    <value>DO $$ 
    BEGIN
        BEGIN
            ALTER TABLE {0} DROP COLUMN {1};
        EXCEPTION
            WHEN undefined_column THEN RAISE NOTICE 'column {1} does not exist in {0}.';
        END;
    END;
$$</value>
  </data>
</root>