<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ClosePreviousJobs_Update_SCRIPT" xml:space="preserve">
    <value>with updated_rows as (
	update sync_table
	set
		job_state = 'skipped'
		,job_log = @job_log
		,job_closed_by_job_id = @job_closed_by_job_id
		,job_last_change = @job_last_change
		,job_start = now() at time zone 'utc'
		,job_end = now() at time zone 'utc'
		,job_to_fso_can_sync = true
	where
		job_source_sosync_write_date &lt; @job_source_sosync_write_date
		and job_source_system = @job_source_system
		and job_source_model = @job_source_model
		and job_source_record_id = @job_source_record_id
		and job_state = 'new'
	returning job_id
)
select count(*) affected_rows from updated_rows;</value>
  </data>
  <data name="CreateIndex3_SCRIPT" xml:space="preserve">
    <value>create index get_first_open_jobs_idx on sync_table
using btree
(job_date desc, job_state, parent_job_id)
where (job_state = 'new'::text and parent_job_id is null)</value>
  </data>
  <data name="CreateProtocolIndex_SCRIPT" xml:space="preserve">
    <value>create index protocol_idx
	on sync_table (job_last_change desc, job_to_fso_can_sync, job_to_fso_sync_version)
    where job_to_fso_can_sync = true
    AND (job_to_fso_sync_version is null
         or job_to_fso_sync_version &lt; job_last_change
         or job_to_fso_sync_version &gt; job_last_change );</value>
  </data>
  <data name="GetAllOpenSyncJobs_SELECT" xml:space="preserve">
    <value>with recursive children as (
	-- roots
	select *
	from sync_table
	where parent_job_id is null and job_state in ('new', 'inprogress')

	union all
	
	-- children
	select child.*
	from sync_table as child
	inner join sync_table parent on child.parent_job_id = parent.job_id
)
select * from children;</value>
  </data>
  <data name="GetFirstOpenSynJobAndChildren_SELECT" xml:space="preserve">
    <value>with recursive children as (
	-- roots
	select * from (
		select *
		from sync_table
		where job_date &gt; now() - interval '15 days' and parent_job_id is null and job_state = 'new'
        order by job_date desc
        limit 50
	) first_parent

	union all
	
	-- children
	select jobs.*
	from sync_table jobs
	inner join children c on c.job_id = jobs.parent_job_id
)
select * from children order by job_date asc;</value>
  </data>
  <data name="GetProtocolToSync_SELECT" xml:space="preserve">
    <value>SELECT * FROM sync_table
 	WHERE job_to_fso_can_sync = true
    	AND (job_to_fso_sync_version is null
         	 or job_to_fso_sync_version &lt; job_last_change
         	 or job_to_fso_sync_version &gt; job_last_change)
    ORDER BY job_last_change desc
    LIMIT 100;</value>
  </data>
  <data name="JobStatistics_SCRIPT" xml:space="preserve">
    <value>select
	count(*) Total
	,sum(case when job_state = 'new' then 1 else 0 end) new
	,sum(case when job_state = 'inprogress' then 1 else 0 end) in_progress
	,sum(case when job_state = 'error' then 1 else 0 end) error
	,sum(case when job_state = 'done' then 1 else 0 end) done
from
	sync_table;</value>
  </data>
  <data name="SetupAddColumn_SCRIPT" xml:space="preserve">
    <value>DO $$ 
    BEGIN
        BEGIN
            ALTER TABLE {0} ADD COLUMN {1} {2};
        EXCEPTION
            WHEN duplicate_column THEN RAISE NOTICE 'column {1} already exists in {0}.';
        END;
    END;
$$</value>
  </data>
  <data name="SetupDatabase_SCRIPT" xml:space="preserve">
    <value>CREATE TABLE IF NOT EXISTS sync_table
(
 -- SyncJob
  job_id serial constraint synctable_primary_key primary key,
  job_date timestamp without time zone not null,
  
  -- Sosync only
  job_fs_id integer,
  job_fso_id integer,
  job_last_change timestamp without time zone,
  
  -- SyncJob source
  job_source_system text,
  job_source_model text,
  job_source_record_id integer not null,
  
  -- SyncJob info
  job_fetched timestamp without time zone,
  job_start timestamp without time zone,
  job_end timestamp without time zone,
  job_run_count integer not null default 0,
  job_state text not null,
  job_error_code text,
  job_error_text text,
  job_log text,
  
  -- Parent job_child_end
  parent_job_id integer,

  -- Child jobs processing time
  child_job_start timestamp without time zone,
  child_job_end timestamp without time zone,
  
  -- Synchronization source
  sync_source_system text,
  sync_source_model text,
  sync_source_record_id integer,

  -- Synchronization target
  sync_target_system text,
  sync_target_model text,
  sync_target_record_id integer,
  
  -- Synchronization info
  sync_source_data text,
  sync_target_data_before text,
  sync_target_request text,
  sync_target_answer text,

  -- Synchronization processing time
  sync_start timestamp without time zone,
  sync_end timestamp without time zone
)
with (
  OIDS=false
);</value>
  </data>
  <data name="SetupDropColumn_SCRIPT" xml:space="preserve">
    <value>DO $$ 
    BEGIN
        BEGIN
            ALTER TABLE {0} DROP COLUMN {1};
        EXCEPTION
            WHEN undefined_column THEN RAISE NOTICE 'column {1} does not exist in {0}.';
        END;
    END;
$$</value>
  </data>
  <data name="SkipPreviousJobsIndex_SCRIPT" xml:space="preserve">
    <value>create index skip_jobs_idx on sync_table
using btree
(
		job_source_sosync_write_date
		,job_source_system
		,job_source_model
		,job_source_record_id
		,job_state
)
where (job_state = 'new'::text);</value>
  </data>
  <data name="SyncJobToSyncIndex" xml:space="preserve">
    <value>create index syncjob_sync_index1 on sync_table (job_to_fso_can_sync);
create index syncjob_sync_index2 on sync_table (job_to_fso_sync_version NULLS FIRST);
create index syncjob_sync_index3 on sync_table (job_last_change);</value>
  </data>
</root>